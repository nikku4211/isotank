#!/usr/bin/env python3
#
# Wavefront to Varooom Converter
# Copyright 2024 Nikku4211
#
# Copying and distribution of this file, with or without
# modification, are permitted in any medium without royalty
# provided the copyright notice and this notice are preserved.
# This file is offered as-is, without any warranty.
#
import os 
import sys
import math

#thanks gvaliente
def sub(a, b):
    result = []

    for i in range(len(a)):
        result.append(a[i] - b[i])

    return result


def cross(a, b):
    return [a[1]*b[2] - a[2]*b[1], a[2]*b[0] - a[0]*b[2], a[0]*b[1] - a[1]*b[0]]


def norm(v):
    return math.sqrt((v[0] * v[0]) + (v[1] * v[1]) + (v[2] * v[2]))


def normal(p0, p1, p2):
    # cross_product = np.cross(p1 - p0, p2 - p0)
    cross_product = cross(sub(p1, p0), sub(p2, p0))
    # normal = cross_product / np.linalg.norm(cross_product)
    magnitude = norm(cross_product)
    return [cross_product[0] / magnitude, cross_product[1] / magnitude, cross_product[2] / magnitude]


def main(argv):
    #handle arguments and help
    if len(argv) >= 2 and argv[1] in ('--help', '-h'):
        print('usage: objinput moloutput modelname modelscale')
        sys.exit(1)
    elif len(argv) < 4:
        print('too few arguments, need --help?')
        sys.exit(1)
    
    #recalculating vertex normals is optional
    recalcvertexnorms = True if len(argv) >= 6 and argv[5] in ('-rn', '--recalcnorms') else False
    waveobjfile = open(argv[1],"rt")
    waveobjdata = waveobjfile.readlines()
    
    wavemtlfilename = []
    
    #get material file from obj file
    for x in range(len(waveobjdata)):
        if waveobjdata[x][0:7] == "mtllib ":
            wavemtlfilename = os.path.dirname(os.path.abspath(argv[1])) + "/" + waveobjdata[x].split()[1]
            
    wavemtlfile = open(wavemtlfilename,"rt")
    wavemtldata = wavemtlfile.readlines()
    
    #wavefront variables
    wavevertices = []
    wavevertexnorms = []
    wavefacels = []
    wavecolours = []
    wavematerialcurrent = -1
    wavematerialindices = []
    wavematerialnames = []
    
    molfile = open(argv[2], 'wt')
    
    modelname = argv[3]
    
    modelscale = float(argv[4])
    
    molfile.write("""
    /*
     * Generated by Nikku4211's Wavefront to Molasses Converter
     * Nikku4211 - github.com/nikku4211/
     * 
     */

.segment "ABS0DATA"
.align 256
%s_x:\n""" % (modelname))
    
    #read vertices as specified in the obj file and then scale them
    for x in range(len(waveobjdata)):
        if waveobjdata[x][0:2] == "v ":
            waveverticesub = []
            for i in range(len(waveobjdata[x][2::].split())):
                waveverticesub.append(float(waveobjdata[x][2::].split()[i])*modelscale)
            wavevertices.append(waveverticesub)
            molfile.write('  .word '
            + "".join('%s' % str((math.floor(float(waveobjdata[x][2::].split()[0])*modelscale) << 8) & 65535))
            + "\n"
            )
            
    molfile.write("%s_y:\n" % modelname)
    
    #read vertices as specified in the obj file and then scale them
    for x in range(len(waveobjdata)):
        if waveobjdata[x][0:2] == "v ":
            waveverticesub = []
            for i in range(len(waveobjdata[x][2::].split())):
                waveverticesub.append(float(waveobjdata[x][2::].split()[i])*modelscale)
            wavevertices.append(waveverticesub)
            molfile.write('  .word ' 
            + "".join('%s' % str((math.floor(float(waveobjdata[x][2::].split()[1])*modelscale) << 8) & 65535))
            + "\n"
            )
            
    molfile.write("%s_z:\n" % modelname)
    
    #read vertices as specified in the obj file and then scale them
    for x in range(len(waveobjdata)):
        if waveobjdata[x][0:2] == "v ":
            waveverticesub = []
            for i in range(len(waveobjdata[x][2::].split())):
                waveverticesub.append(float(waveobjdata[x][2::].split()[i])*modelscale)
            wavevertices.append(waveverticesub)
            molfile.write('  .word ' 
            + "".join('%s' % str((math.floor(float(waveobjdata[x][2::].split()[2])*modelscale) << 8) & 65535))
            + "\n"
            )
    
    # molfile.write("%s_colour:\n" % modelname)
    
    #convert floating point rgb components specified in obj to 5-bit integers
    for x in range(len(wavemtldata)):
        if wavemtldata[x][0:3] == "Kd ":
            if wavemtldata[x][3::] not in wavecolours:
                wavecolours.append(wavemtldata[x][3::])
            wavematerialnames.append(wavemtldata[x-3][7::])
            wavematerialnames.append(wavemtldata[x][3::])
    #print(wavematerialnames)
    
    #if we're not recalculating the vertex normals, take them as specified in the obj
    #and in either case, take the face vertex indices as specified in the obj
    for x in range(len(waveobjdata)):
        if waveobjdata[x][0:3] == "vn " and recalcvertexnorms == False:
            wavevertexnormssub = []
            for i in range(len(waveobjdata[x][3::].split())):
                wavevertexnormssub.append(waveobjdata[x][3::].split()[i])
            wavevertexnorms.append(wavevertexnormssub)
        if waveobjdata[x][0:2] == "f ":
            wavefacelnormindices = []
            for i in range(len(waveobjdata[x][2::].split())):
                if waveobjdata[x][2::].find('/'):
                    wavefacelnormindices.append(str(int(waveobjdata[x][2::].split()[i].split("/")[0])-1))
                else:
                    wavefacelnormindices.append(str(int(waveobjdata[x][2::].split()[i])-1))
            wavefacels.append(wavefacelnormindices)
            if waveobjdata[x-1][0:7] == "usemtl " and wavematerialnames[wavematerialnames.index(waveobjdata[x-1][7::])+1] not in wavematerialnames[:(wavematerialnames.index(waveobjdata[x-1][7::]))]:
                wavematerialcurrent += 1
                #print(wavematerialcurrent)
            wavematerialindices.append(wavematerialcurrent)
    #print(wavefacels)      
    #if we're recalculating the vertex normals, take the sum of the cross product of all the vertices
    if recalcvertexnorms == True:
        for x in range(len(wavefacels)):
            p0 = wavevertices[int(wavefacels[x][0])]
            p1 = wavevertices[int(wavefacels[x][1])]
            p2 = wavevertices[int(wavefacels[x][2])]
            #print(wavevertices[int(wavefacels[x][0])])
            #print(wavevertices[int(wavefacels[x][1])])
            #print(wavevertices[int(wavefacels[x][2])])
            wavevertexnormssub = normal(p0, p1, p2)
            wavevertexnorms.append(wavevertexnormssub)
            #print(wavevertexnorms[x])
    
    waveedges = []
    
    for x in range(len(wavevertexnorms)):
        for y in range(len(wavefacels[x])):
            waveedgessub = []
            waveedgessub.append(wavefacels[x][y])
            if y < len(wavefacels[x]) - 1:
                waveedgessub.append(wavefacels[x][y+1])
            else:
                waveedgessub.append(wavefacels[x][0])
            waveedges.append(tuple(waveedgessub))
    
    auwaveedges = list(set(waveedges))
    
    print(auwaveedges)
    uniquewaveedges = []
    
    for j in range(len(auwaveedges)):
        for e in range(len(auwaveedges)):
            if not ((auwaveedges[e][0] == auwaveedges[j][0] and auwaveedges[e][1] == auwaveedges[j][1]) or (auwaveedges[e][0] == auwaveedges[j][1] and auwaveedges[e][1] == auwaveedges[j][0])):
                uniquewaveedges.append(auwaveedges[e])
                
    uniquewaveedges = set(uniquewaveedges)
    print(uniquewaveedges)
            
    
    molfile.write("\n%s_edge1:\n" % (modelname))
    
    for x in range(len(wavevertexnorms)):
        molfile.write('  .byte ')
        for y in range(len(wavefacels[x])):
            if y > 0:
                if wavefacels[x][y] not in waveedges or wavefacels[x][y-1] not in waveedges:
                    molfile.write(wavefacels[x][y])
                    if y < (len(wavefacels[x]) - 1):
                        molfile.write(",")
                    waveedges.append(wavefacels[x][y])
            else:
                if wavefacels[x][y] not in waveedges or wavefacels[x][len(wavefacels[x]) - 1] not in waveedges:
                    molfile.write(wavefacels[x][y])
                    if y < (len(wavefacels[x]) - 1):
                        molfile.write(",")
                    waveedges.append(wavefacels[x][y])
            
        molfile.write('\n')
    
    molfile.write("\n%s_edge2:\n" % (modelname))
    
    for x in range(len(wavevertexnorms)):
        molfile.write('  .byte ')
        for y in range(len(wavefacels[x])):
            if y < (len(wavefacels[x]) - 1):
                molfile.write(wavefacels[x][y + 1])
                molfile.write(",")
            else:
                molfile.write(wavefacels[x][0])
        molfile.write('\n')
        
    molfile.write("""
%s_faces:\n""" % (modelname))
    #then put all the vertex normals together in the mol header file
    for x in range(len(wavevertexnorms)):
        molfile.write('  .word '
        + "".join("%s" % str((math.floor(float(wavevertexnorms[x][0])) << 8) & 65535))
        + ","
        + "".join("%s" % str((math.floor(float(wavevertexnorms[x][1])) << 8) & 65535))
        + ","
        + "".join("%s" % str((math.floor(float(wavevertexnorms[x][2])) << 8) & 65535))
        + "\n"
        )
        
    molfile.write("\n%s_vertex_count:\n  .word %d\n" % (modelname, (len(wavevertices) // 3) << 1))
    molfile.write("\n%s_edge_count:\n  .word %d\n" % (modelname, len(wavefacels) << 1))
    

if __name__=='__main__':
    main(sys.argv)